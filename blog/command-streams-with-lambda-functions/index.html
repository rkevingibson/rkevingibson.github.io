<!DOCTYPE html>
<html lang="en-US">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Don&#39;t panic">

<base href="">
<title>


     Command Streams with Lambda Functions 

</title>
<link rel="canonical" href="/blog/command-streams-with-lambda-functions/">


<script type="text/javascript">
    var baseURL = '';
    var host = baseURL.substring(0, baseURL.length - 1).replace(/\//g, '');
    if ((host === window.location.host) && (window.location.protocol !== 'https:')) {
        window.location.protocol = 'https:';
    }
</script>





<link rel="stylesheet" href="/css/reset.css">
<link rel="stylesheet" href="/css/pygments.css">
<link rel="stylesheet" href="/css/main.css">






<link rel="shortcut icon"

    href="/img/leaf.ico"

>



</head>


<body lang="en">

<section class="header"> 
    <div class="container">
        <div class="content">
            <a href="/"><div class="name">Kevin Gibson</div></a>
            <nav>
                <ul>
                    <a href="/blog/"><li>Blog</li></a>
                    <a href="/about/"><li>About</li></a>
                    <a href="/projects/"><li>Projects</li></a>
                </ul>
            </nav>
        </div>
    </div>
</section>

<section class="icons">
    <div class="container">
        <div class="content">

        
            <a href="//github.com/rkevingibson" target="_blank">
                <i class="icon ion-social-github"></i>
            </a>
        
        
        
            <a href="//twitter.com/kevingibson92" target="_blank">
                <i class="icon ion-social-twitter"></i>
            </a>
        

        
            <a href="//linkedin.com/in/rkevingibson" target="_blank">
                <i class="icon ion-social-linkedin"></i>
            </a>
        

        

        

        
            <a href="mailto:gibson@dgp.toronto.edu">
                <i class="icon ion-ios-email larger"></i>
            </a>
        
        </div>
    </div>
</section>


<section class="main post non-narrow zero-top-spacing">
    <div class="container">
        <div class="content">
            <div class="front-matter">
                <div class="title-container">
                    <div class="page-heading">

    Command Streams with Lambda Functions

</div>

                    <div class="initials"><a href="">ad</a></div>
                </div>
                <div class="meta">
                    <div class="date" title="Fri Feb 10 2017 12:22:17 -0500">Feb 10, 2017</div>
                    <div class="reading-time"><div class="middot"></div>5 minutes read</div>
                </div>
            </div>
            <div class="markdown">
                

<p>I&rsquo;ve been working on a rendering backend to make creating quick-and-dirty OpenGL projects easier - basically a simple game engine that I&rsquo;m comfortable breaking apart and toying with. Right now I&rsquo;m splitting off my OpenGL backend to run on a separate thread, so that while the engine is simulating frame <code>N+1</code>, the render thread is drawing frame <code>N</code>. Since I don&rsquo;t want to have a massive sync point between the two threads, and I don&rsquo;t want to surround everything in mutexes, I&rsquo;ll need to have two copies of a lot of data: one that is owned by the render thread, and one that is owned by the game thread. When the game thread changes something (say, the position of a mesh), the render thread will need to know about it for the next thread. This means syncing data between two threads. I came up with a fairly nice way to do that that I think is worth sharing. This technique has been somewhat synthesized from two other locations: The Autodesk Stingray <a href="http://bitsquid.blogspot.ca/2016/09/state-reflection.html">blog post on state reflection</a>, and <a href="https://blog.molecular-matters.com/2014/12/16/stateless-layered-multi-threaded-rendering-part-3-api-design-details/">this post</a> by Stefan Reinalter on command buckets in his Molecule engine.</p>

<p>In a nutshell, the problem is as follows: we have some data on the main thread of the program, which needs to get propagated to the render thread. This data probably has some associated action that needs to be taken: maybe it&rsquo;s a buffer that needs to be copied to the GPU, or maybe its a filepath that I&rsquo;m telling the GPU thread to load a shader from. I use a command queue, which essentially is a chunk of memory that the main thread can push commands on to, along with their associated data, and then the render thread can read from. A command is a POD type that looks like this:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#080;font-weight:bold">struct</span> Cmd
{
	<span style="color:#080;font-weight:bold">using</span> DispatchFn <span style="color:#333">=</span> <span style="color:#339;font-weight:bold">void</span>(<span style="color:#333">*</span>)(Cmd<span style="color:#333">*</span>);
	DispatchFn dispatch;
	size_t command_size;
}
</code></pre></div>

<p>Each command has a pointer to a function that can be executed, and a <code>command_size</code> field which is used by the queue.</p>

<p>Commands that inherit from this struct get pushed onto a <code>CommandStream</code> object, that has an API like this:
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#080;font-weight:bold">class</span><span style="color:#f00;background-color:#faa"> </span><span style="color:#b06;font-weight:bold">CommandStream</span>
{
<span style="color:#080;font-weight:bold">public</span><span style="color:#333">:</span>

	<span style="color:#888">//Run every command in the queue
</span><span style="color:#888"></span>	<span style="color:#339;font-weight:bold">void</span> ExecuteAll();

	<span style="color:#888">//Add a new command to the queue
</span><span style="color:#888"></span>	<span style="color:#080;font-weight:bold">template</span><span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">typename</span> T<span style="color:#333">&gt;</span>
	<span style="color:#339;font-weight:bold">bool</span> Push(<span style="color:#080;font-weight:bold">const</span> T<span style="color:#333">&amp;</span> t);
}
</code></pre></div></p>

<p>In a bit, I&rsquo;ll go through the details of these functions, and how the <code>CommandStream</code> stores the commands, but first, let&rsquo;s see how easy it is to use. One of my main goals was to make the code easy to read and follow - the functions that the main thread calls to interact with the render thread aren&rsquo;t executing until later, which if you&rsquo;re not careful can end up making code that seems related end up all over the place. This is where C++11&rsquo;s lambda functions come in to play! For example, say we have a function that wants to tell the renderer to update the position of some mesh in the game world. That might look something like</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">UpdateMeshTransform</span>(MeshHandle mesh, <span style="color:#080;font-weight:bold">const</span> Transform<span style="color:#333">&amp;</span> transform)
{
	<span style="color:#080;font-weight:bold">struct</span> <span style="color:#970;font-weight:bold">CmdType</span> : Cmd
	{
		MeshHandle m;
		Transform t;
	} cmd;
	cmd.m <span style="color:#333">=</span> mesh;
	cmd.t <span style="color:#333">=</span> transform;

	cmd.dispatch <span style="color:#333">=</span> [](Cmd<span style="color:#333">*</span> cmd) {
		<span style="color:#080;font-weight:bold">auto</span> data <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>CmdType<span style="color:#333">*&gt;</span>(cmd);
		<span style="color:#888">//Copy transform info to the appropriate mesh.
</span><span style="color:#888"></span>		render_meshes[data<span style="color:#333">-&gt;</span>m] <span style="color:#333">=</span> data<span style="color:#333">-&gt;</span>t;
	};

	render_commands.Push(cmd);
}
</code></pre></div>

<p>So here we create a type that inherits from the <code>Cmd</code> struct, which let&rsquo;s us put in arbitrary data. Then we use a <em>captureless</em> lambda to define a function that will be run by the render thread when it calls <code>render_commands.ExecuteAll()</code>. It is important that the lambda be captureless - this lets it get converted to a function pointer. A nice feature is that even though the lambda is defined here, unlike lambdas which capture, its lifetime is the same as a functions - that is, forever. This could equally be replaced by some pointer to a function that is defined elsewhere, but what I like about this is that the behaviour is very clear when you read this function.</p>

<p>So how does the <code>CommandStream</code> work? Well, in order to make it safe for us to use, internally it has two buffers: a <code>write_buffer_</code>, and and <code>execute_buffer_</code>. When a new command is added, memory is allocated from a linear allocator - so every command will come directly after the previously added one (see <a href="https://blog.molecular-matters.com/2013/01/29/memory-allocation-strategies-a-growing-stack-like-lifo-allocator/">this post</a> for a sample implementation). The push function ends up being dead simple:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#080;font-weight:bold">template</span><span style="color:#333">&lt;</span><span style="color:#080;font-weight:bold">typename</span> T<span style="color:#333">&gt;</span>
<span style="color:#080;font-weight:bold">inline</span> <span style="color:#339;font-weight:bold">bool</span> Push(<span style="color:#080;font-weight:bold">const</span> T<span style="color:#333">&amp;</span> t)
{
	<span style="color:#080;font-weight:bold">static_assert</span>(std<span style="color:#333">::</span>is_base_of<span style="color:#333">&lt;</span>Cmd, T<span style="color:#333">&gt;::</span>value, <span style="background-color:#fff0f0">&#34;Adding invalid command&#34;</span>);
	
	<span style="color:#080;font-weight:bold">auto</span> block <span style="color:#333">=</span> write_buffer_<span style="color:#333">-&gt;</span>Allocate(<span style="color:#080;font-weight:bold">sizeof</span>(T));
	
	<span style="color:#080;font-weight:bold">if</span> (block.ptr <span style="color:#333">==</span> <span style="color:#080;font-weight:bold">nullptr</span>) {
		<span style="color:#888">//Our allocator is out of memory.
</span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">false</span>;
	}

	memcpy(block.ptr, <span style="color:#333">&amp;</span>t, <span style="color:#080;font-weight:bold">sizeof</span>(T));
	<span style="color:#080;font-weight:bold">auto</span> cmd <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>Cmd<span style="color:#333">*&gt;</span>(block.ptr);
	cmd<span style="color:#333">-&gt;</span>command_size <span style="color:#333">=</span> block.length;
	<span style="color:#080;font-weight:bold">return</span> <span style="color:#007020">true</span>;
}
</code></pre></div>

<p>Note that we
At the end of a frame, we have a sync point between the main thread and the render thread. At this sync, we swap the two buffers, so that any of the previous frame&rsquo;s render commands can be executed by the render thread, while the game thread can do whatever it wants. The swapping is simple:</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#080;font-weight:bold">inline</span> <span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">SwapBuffers</span>()
{
	std<span style="color:#333">::</span>swap(execute_buffer_, write_buffer_); <span style="color:#888">// Swap the pointers
</span><span style="color:#888"></span>	write_buffer_<span style="color:#333">-&gt;</span>DeallocateAll();            <span style="color:#888">// Clear all the commands
</span><span style="color:#888"></span>}
</code></pre></div>

<p>Finally, since all the commands are right after each other in memory, execution is equally straightforward - loop over the buffer, and call the dispatch function for each one.</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#339;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">ExecuteAll</span>()
{
	<span style="color:#080;font-weight:bold">auto</span> execute_pos_ <span style="color:#333">=</span> execute_buffer_<span style="color:#333">-&gt;</span>Begin();
	<span style="color:#080;font-weight:bold">while</span> (read_pos_ <span style="color:#333">&lt;</span> execute_buffer_<span style="color:#333">-&gt;</span>End()) {
		Cmd<span style="color:#333">*</span> cmd <span style="color:#333">=</span> <span style="color:#080;font-weight:bold">reinterpret_cast</span><span style="color:#333">&lt;</span>Cmd<span style="color:#333">*&gt;</span>(read_pos_);
		cmd<span style="color:#333">-&gt;</span>dispatch(cmd);
		read_pos_ <span style="color:#333">=</span> read_pos_ <span style="color:#333">+</span> cmd<span style="color:#333">-&gt;</span>command_size;
	}
}
</code></pre></div>

<p>And that&rsquo;s it! A reasonably simple way to create a command stream that can be used to communicate between threads. Next, I want to expand on this to make <code>Push</code> thread-safe, so that multiple worker threads can be making render calls at the same time. Fortunately, this is as simple as making sure that the <code>Allocate</code> function is thread safe, which is rather nice. For now, I&rsquo;ve gotten my render thread working separately, which I&rsquo;m quite happy with. Hopefully in future posts I&rsquo;ll be able to share some of the images that I&rsquo;ll generate using this codebase!</p>

<h2 id="update">Update</h2>

<p>I&rsquo;ve realised that this is actually a flawed design - I&rsquo;m doing two copies for every command. The solution would be to change the <code>Push(T&amp;)</code> function to look like <code>T* Push&lt;T&gt;()</code>, and call it before filling out the command struct. Simple enough, really.</p>

                <br>
                <p><a href="/blog/">Back to posts</a></p>
            </div>
            <br>
            <div class="disqus">
                
            </div>
        </div>
    </div>
</section>

<script>window.markdeepOptions = {mode: 'html'}</script>

    <script src="/js/markdeep.min.js"></script>



</body>
</html>

